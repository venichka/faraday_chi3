#!/usr/bin/env python3
"""
3D pump–probe simulation of Faraday rotation in an optimized DBR cavity.

Geometry:
    - Read from optimized_geometry.json (generated by optimize_cavity_geometry.py)
    - Layers are stacked along +z with finite cross-section in x/y.

Sources (normal incidence along +z):
    Pump 1 : frequency ω1 (from cavity_modes.json), circular e⁺ (Ex + i Ey)/√2,
             peak intensity 1 TW/cm², 100 fs duration.
    Pump 2 : frequency ω2 (from cavity_modes.json), circular e⁻ (Ex − i Ey)/√2,
             peak intensity 1 TW/cm², 100 fs duration.
    Probe  : frequency ωs (from cavity_modes.json), linear 45° (Ex + Ey)/√2,
             peak intensity 10 MW/cm², 100 fs duration.

Material:
    - SiN uses isotropic χ³ corresponding to n₂ ≈ 2.5×10⁻¹⁹ m²/W.
    - SiO₂ and air are linear.

Outputs:
    - Temporal traces of intensities at ωs (e⁺/e⁻ projections), ω₁, ω₂,
      and sidebands ωs ± (ω₁ - ω₂).
    - Probe polarization-rotation angle vs time.
    - Field-magnitude snapshots (x–y and x–z planes) at a selected time.

Two run modes are supported:
    quick : coarse resolution and reduced intensities for a rapid sanity check.
    full  : high resolution and physical intensities suitable for production runs.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Sequence, Tuple

import matplotlib.pyplot as plt
import meep as mp
import numpy as np

from geometry_io import read_json as load_geometry_json, material_factory
from mode_targeting import material_index_at_wavelength, get_cavity_materials

# --------------------------------------------------------------------------- #
# Physical constants (SI units)
# --------------------------------------------------------------------------- #
EPS0 = 8.854187817e-12
C0 = 299792458.0
UM = 1.0  # μm as Meep length unit

SCALE_E = 1.0 / (1e-6 * EPS0 * C0)  # converts Meep E-field (μm units) → SI


# --------------------------------------------------------------------------- #
# Helpers for field <-> intensity conversions
# --------------------------------------------------------------------------- #
def intensity_to_meep_amplitude(intensity_w_cm2: float, n_lin: float) -> float:
    """Convert plane-wave intensity (W/cm²) to Meep electric-field amplitude."""
    intensity_si = intensity_w_cm2 * 1e4  # cm² → m²
    e_si = np.sqrt(2.0 * intensity_si / (n_lin * EPS0 * C0))
    return float(e_si / SCALE_E)


def meep_field_to_intensity(field: np.ndarray, n_lin: float) -> np.ndarray:
    """Return intensity (W/cm²) from complex field envelope (Meep units)."""
    e_si = np.abs(field) * SCALE_E
    intensity_si = 0.5 * n_lin * EPS0 * C0 * e_si**2
    return intensity_si / 1e4


def df_from_bandwidth(lam_um: float, dlam_nm: float) -> float:
    """Gaussian fwidth parameter from bandwidth (nm) centered at lam_um."""
    return (dlam_nm * 1e-3) / (lam_um * lam_um)


# --------------------------------------------------------------------------- #
# Dataclasses for run configuration and geometry metadata
# --------------------------------------------------------------------------- #
@dataclass
class RunParams:
    name: str
    resolution: int
    span_xy: float
    dpml_xy: float
    dpml_z: float
    src_buffer: float
    runtime_factor: float
    pulse_duration_fs: float
    pump_band_nm: float
    probe_band_nm: float
    pump_intensity_w_cm2: float
    probe_intensity_w_cm2: float
    nonlinear_scale: float
    sample_dt: float
    lp_tau: float
    capture_fields: bool
    pump_cutoff: float


def quick_params() -> RunParams:
    return RunParams(
        name="quick",
        resolution=32,
        span_xy=1.2,
        dpml_xy=0.6,
        dpml_z=1.0,
        src_buffer=0.25,
        runtime_factor=5.0,
        pulse_duration_fs=25.0,
        pump_band_nm=20.0,
        probe_band_nm=6.0,
        pump_intensity_w_cm2=5.0e5,
        probe_intensity_w_cm2=1.0e2,
        nonlinear_scale=0.05,
        sample_dt=0.015,
        lp_tau=0.3,
        capture_fields=True,
        pump_cutoff=1.5,
    )


def full_params() -> RunParams:
    return RunParams(
        name="full",
        resolution=100,
        span_xy=3.0,
        dpml_xy=1.0,
        dpml_z=1.0,
        src_buffer=0.5,
        runtime_factor=6.0,
        pulse_duration_fs=100.0,
        pump_band_nm=30.0,
        probe_band_nm=10.0,
        pump_intensity_w_cm2=1.0e12,
        probe_intensity_w_cm2=1.0e7,
        nonlinear_scale=1.0,
        sample_dt=0.05,
        lp_tau=0.8,
        capture_fields=True,
        pump_cutoff=4.0,
    )


# --------------------------------------------------------------------------- #
# Geometry loaders
# --------------------------------------------------------------------------- #
def load_cavity_modes(path: Path) -> Dict[str, Dict[str, float]]:
    if not path.exists():
        raise FileNotFoundError(
            f"{path} not found. Run fp_cavity_modes_spectrum.py first to generate it."
        )
    with path.open("r") as f:
        return json.load(f)


def build_geometry_from_spec(
    spec: Dict,
    mats: Dict[str, mp.Medium],
    core_span_xy: float,
    dpml_z: float,
    margin_z: float = 0.4,
) -> Tuple[List[mp.Block], float, float]:
    """Create a 3D geometry list from the optimized geometry JSON."""
    pad_air = float(spec["pads"]["air_um"])
    pad_sub = float(spec["pads"]["substrate_um"])
    dpml_geom = float(spec["pads"]["pml_um"])
    dpml_z = max(dpml_z, dpml_geom)

    left_layers = spec["mirrors"]["left"]
    right_layers = spec["mirrors"]["right"]
    cavity_thk = float(spec["cavity"]["L_um"])
    cavity_mat = mats[spec["cavity"]["mat"]]
    spacer_left = float(spec.get("spacers", {}).get("left_um", 0.0))
    spacer_right = float(spec.get("spacers", {}).get("right_um", 0.0))

    def layer_sum(layers: Sequence[Dict[str, float]]) -> float:
        return sum(layer["thk_um"] for layer in layers)

    stack_len = (
        pad_air
        + layer_sum(left_layers)
        + spacer_left
        + cavity_thk
        + spacer_right
        + layer_sum(right_layers)
        + pad_sub
    )

    cell_z = stack_len + 2 * dpml_z + margin_z
    geometry: List[mp.Block] = []
    xy_size = core_span_xy

    def add_block(z_start: float, thickness: float, mat: mp.Medium) -> float:
        center_z = z_start + 0.5 * thickness
        geometry.append(
            mp.Block(
                center=mp.Vector3(0, 0, center_z),
                size=mp.Vector3(xy_size, xy_size, thickness),
                material=mat,
            )
        )
        return z_start + thickness

    z = -0.5 * cell_z + dpml_z
    z += pad_air

    for layer in left_layers:
        z = add_block(z, layer["thk_um"], mats[layer["mat"]])

    if spacer_left > 0:
        z = add_block(z, spacer_left, mats["SiO2"])

    cavity_start = z
    z = add_block(z, cavity_thk, cavity_mat)
    cavity_center = cavity_start + 0.5 * cavity_thk

    if spacer_right > 0:
        z = add_block(z, spacer_right, mats["SiO2"])

    for layer in right_layers:
        z = add_block(z, layer["thk_um"], mats[layer["mat"]])

    z = add_block(z, pad_sub, mats["SiO2"])

    return geometry, cell_z, cavity_center


def load_geometry(path: Path, core_span_xy: float, dpml_z: float) -> Tuple[List[mp.Block], float, float, Dict[str, mp.Medium], Dict]:
    spec = load_geometry_json(str(path))
    mats = {
        name: material_factory(name, entry, mp)
        for name, entry in spec["materials"].items()
    }
    geometry, cell_z, cavity_center = build_geometry_from_spec(spec, mats, core_span_xy, dpml_z)
    return geometry, cell_z, cavity_center, mats, spec


# --------------------------------------------------------------------------- #
# Source builders
# --------------------------------------------------------------------------- #
def circular_sources(
    frequency: float,
    fwidth: float,
    cutoff: float,
    amplitude: float,
    handedness: str,
    src_center: mp.Vector3,
    src_span: float,
) -> List[mp.Source]:
    """Return (Ex, Ey) sources for circular polarization."""
    phase = 1.0j if handedness == "plus" else -1.0j
    amp = amplitude / np.sqrt(2.0)
    base = mp.GaussianSource(frequency=frequency, fwidth=fwidth, cutoff=cutoff)
    size = mp.Vector3(src_span, src_span, 0)
    return [
        mp.Source(src=base, component=mp.Ex, center=src_center, size=size, amplitude=amp),
        mp.Source(src=base, component=mp.Ey, center=src_center, size=size, amplitude=amp * phase),
    ]


def linear_sources_45deg(
    frequency: float,
    fwidth: float,
    cutoff: float,
    amplitude: float,
    src_center: mp.Vector3,
    src_span: float,
) -> List[mp.Source]:
    amp = amplitude / np.sqrt(2.0)
    base = mp.GaussianSource(frequency=frequency, fwidth=fwidth, cutoff=cutoff)
    size = mp.Vector3(src_span, src_span, 0)
    return [
        mp.Source(src=base, component=mp.Ex, center=src_center, size=size, amplitude=amp),
        mp.Source(src=base, component=mp.Ey, center=src_center, size=size, amplitude=amp),
    ]


# --------------------------------------------------------------------------- #
# Envelope tracker for demodulation
# --------------------------------------------------------------------------- #
class EnvelopeTracker:
    def __init__(self, frequency: float, tau: float):
        self.frequency = frequency
        self.tau = tau
        self.value = 0.0 + 0.0j

    def update(self, field: complex, time: float, dt: float) -> complex:
        alpha = min(1.0, dt / self.tau) if self.tau > 0 else 1.0
        self.value = (1.0 - alpha) * self.value + alpha * field * np.exp(-2j * np.pi * self.frequency * time)
        return self.value


# --------------------------------------------------------------------------- #
# Main simulation driver
# --------------------------------------------------------------------------- #
def run_simulation(args: argparse.Namespace) -> None:
    run = quick_params() if args.mode == "quick" else full_params()

    modes = load_cavity_modes(Path("cavity_modes.json"))
    spec_path = Path("optimized_geometry.json")
    if not spec_path.exists():
        raise FileNotFoundError("optimized_geometry.json not found.")

    core_span = run.span_xy
    geometry, cell_z, cavity_center, materials, spec = load_geometry(
        spec_path,
        core_span_xy=core_span,
        dpml_z=run.dpml_z,
    )

    default_high = float(getattr(materials.get("SiN"), "index", 2.0))
    default_low = float(getattr(materials.get("SiO2"), "index", 1.45))
    mat_sin, mat_sio2 = get_cavity_materials(
        model=args.materials,
        index_high=args.nH if args.nH is not None else default_high,
        index_low=args.nL if args.nL is not None else default_low,
        sin_csv=args.sin_fit,
        sio2_csv=args.sio2_fit,
        fit_poles=args.fit_poles,
    )
    materials["SiN"] = mat_sin
    materials["SiO2"] = mat_sio2
    geometry, cell_z, cavity_center = build_geometry_from_spec(spec, materials, core_span, run.dpml_z)

    # Apply χ³ scaling for SiN
    freq_probe = modes["probe"]["frequency"]
    lam_probe = modes["probe"]["lambda_um"]
    n2_sin = 2.5e-19  # m²/W
    n_linear_probe = material_index_at_wavelength(mat_sin, lam_probe)
    chi3_si = (4.0 / 3.0) * n2_sin * (n_linear_probe**2) * EPS0 * C0
    e_chi3_meep = chi3_si * (SCALE_E**3) * run.nonlinear_scale
    mat_sin.E_chi3_diag = mp.Vector3(e_chi3_meep, e_chi3_meep, e_chi3_meep)

    freq_p1 = modes["pump1"]["frequency"]
    freq_p2 = modes["pump2"]["frequency"]
    lam_p1 = modes["pump1"]["lambda_um"]
    lam_p2 = modes["pump2"]["lambda_um"]
    delta_omega = abs(freq_p1 - freq_p2)
    freq_sb_plus = freq_probe + delta_omega
    freq_sb_minus = max(freq_probe - delta_omega, 0.0)

    n_pump1 = material_index_at_wavelength(mat_sin, lam_p1)
    n_pump2 = material_index_at_wavelength(mat_sin, lam_p2)
    n_probe_lin = material_index_at_wavelength(mat_sin, lam_probe)

    pump_amp1 = intensity_to_meep_amplitude(run.pump_intensity_w_cm2, n_pump1)
    pump_amp2 = intensity_to_meep_amplitude(run.pump_intensity_w_cm2, n_pump2)
    probe_amp = intensity_to_meep_amplitude(run.probe_intensity_w_cm2, n_probe_lin)

    df_probe = df_from_bandwidth(lam_probe, run.probe_band_nm)
    df_pump1 = df_from_bandwidth(lam_p1, run.pump_band_nm)
    df_pump2 = df_from_bandwidth(lam_p2, run.pump_band_nm)

    dpml_layers: List[mp.PML] = [mp.PML(run.dpml_z, direction=mp.Z)]
    if run.dpml_xy > 0:
        dpml_layers.extend([
            mp.PML(run.dpml_xy, direction=mp.X),
            mp.PML(run.dpml_xy, direction=mp.Y),
        ])

    cell = mp.Vector3(core_span + 2 * run.dpml_xy, core_span + 2 * run.dpml_xy, cell_z)
    src_z = -0.5 * cell_z + run.dpml_z + run.src_buffer
    src_center = mp.Vector3(0, 0, src_z)
    src_span = max(core_span - 2 * run.src_buffer, 0.2)

    sources: List[mp.Source] = []
    sources += circular_sources(freq_p1, df_pump1, run.pump_cutoff, pump_amp1, "plus", src_center, src_span)
    sources += circular_sources(freq_p2, df_pump2, run.pump_cutoff, pump_amp2, "minus", src_center, src_span)
    sources += linear_sources_45deg(freq_probe, df_probe, run.pump_cutoff, probe_amp, src_center, src_span)

    sim = mp.Simulation(
        cell_size=cell,
        geometry=geometry,
        sources=sources,
        boundary_layers=dpml_layers,
        resolution=run.resolution,
        force_complex_fields=True,
    )

    pulse_duration_meep = run.pulse_duration_fs * 1e9 / C0
    total_time = run.runtime_factor * pulse_duration_meep

    sample_point = mp.Vector3(0, 0, cavity_center)
    trackers = {
        "probe_plus": EnvelopeTracker(freq_probe, run.lp_tau),
        "probe_minus": EnvelopeTracker(freq_probe, run.lp_tau),
        "probe_Ex": EnvelopeTracker(freq_probe, run.lp_tau),
        "probe_Ey": EnvelopeTracker(freq_probe, run.lp_tau),
        "pump1": EnvelopeTracker(freq_p1, run.lp_tau),
        "pump2": EnvelopeTracker(freq_p2, run.lp_tau),
        "sb_plus": EnvelopeTracker(freq_sb_plus, run.lp_tau),
        "sb_minus": EnvelopeTracker(freq_sb_minus, run.lp_tau),
    }

    histories = {name: [] for name in trackers}
    time_samples: List[float] = []
    field_maps: Dict[str, np.ndarray] = {}
    snapshot_time = 0.6 * total_time

    def callback(simulation: mp.Simulation) -> None:
        t = simulation.meep_time()
        Ex = simulation.get_field_point(mp.Ex, sample_point)
        Ey = simulation.get_field_point(mp.Ey, sample_point)
        E_plus = (Ex + 1j * Ey) / np.sqrt(2.0)
        E_minus = (Ex - 1j * Ey) / np.sqrt(2.0)

        time_samples.append(t)
        trackers["probe_plus"].update(E_plus, t, run.sample_dt)
        trackers["probe_minus"].update(E_minus, t, run.sample_dt)
        trackers["probe_Ex"].update(Ex, t, run.sample_dt)
        trackers["probe_Ey"].update(Ey, t, run.sample_dt)
        trackers["pump1"].update(E_plus, t, run.sample_dt)
        trackers["pump2"].update(E_minus, t, run.sample_dt)
        trackers["sb_plus"].update(E_plus, t, run.sample_dt)
        trackers["sb_minus"].update(E_minus, t, run.sample_dt)

        for name, tracker in trackers.items():
            histories[name].append(tracker.value)

        if run.capture_fields and "xy" not in field_maps and t >= snapshot_time:
            size_xy = mp.Vector3(core_span, core_span, 0)
            field_maps["xy"] = sim.get_array(center=mp.Vector3(), size=size_xy, component=mp.Ey)
            size_xz = mp.Vector3(core_span, 0, cell_z - 2 * run.dpml_z)
            field_maps["xz"] = sim.get_array(center=mp.Vector3(), size=size_xz, component=mp.Ey)

    sim.run(mp.at_every(run.sample_dt, callback), until=total_time)

    times = np.array(time_samples)
    times_fs = times * 1e9 / C0

    I_probe_plus = meep_field_to_intensity(np.array(histories["probe_plus"]), n_probe_lin)
    I_probe_minus = meep_field_to_intensity(np.array(histories["probe_minus"]), n_probe_lin)
    I_pump1 = meep_field_to_intensity(np.array(histories["pump1"]), n_pump1)
    I_pump2 = meep_field_to_intensity(np.array(histories["pump2"]), n_pump2)
    I_sb_plus = meep_field_to_intensity(np.array(histories["sb_plus"]), n_probe_lin)
    I_sb_minus = meep_field_to_intensity(np.array(histories["sb_minus"]), n_probe_lin)

    Ex_env = np.array(histories["probe_Ex"])
    Ey_env = np.array(histories["probe_Ey"])
    Q = np.abs(Ex_env) ** 2 - np.abs(Ey_env) ** 2
    U = 2.0 * np.real(Ex_env * np.conjugate(Ey_env))
    theta_deg = 0.5 * np.degrees(np.arctan2(U, Q))

    fig1, ax1 = plt.subplots(figsize=(9, 4))
    ax1.plot(times_fs, I_pump1, label=r"$\omega_1$ (e$^+$)")
    ax1.plot(times_fs, I_pump2, label=r"$\omega_2$ (e$^-)$")
    ax1.plot(times_fs, I_probe_plus, label=r"$\omega_s$ (e$^+$)")
    ax1.plot(times_fs, I_probe_minus, label=r"$\omega_s$ (e$^-)$")
    ax1.plot(times_fs, I_sb_plus, label=r"$\omega_s + (\omega_1-\omega_2)$")
    ax1.plot(times_fs, I_sb_minus, label=r"$\omega_s - (\omega_1-\omega_2)$")
    ax1.set_xlabel("time (fs)")
    ax1.set_ylabel("Intensity (W/cm²)")
    ax1.set_title("Field intensities vs time at cavity center")
    ax1.legend(loc="upper right", fontsize=8)
    ax1.grid(True, alpha=0.3)

    fig2, ax2 = plt.subplots(figsize=(9, 3))
    ax2.plot(times_fs, theta_deg)
    ax2.set_xlabel("time (fs)")
    ax2.set_ylabel("Probe rotation θ (deg)")
    ax2.set_title("Probe polarization rotation")
    ax2.grid(True, alpha=0.3)

    if run.capture_fields and "xy" in field_maps:
        xy = field_maps["xy"]
        fig3, ax3 = plt.subplots(figsize=(5, 4))
        im = ax3.imshow(
            np.abs(xy.T),
            origin="lower",
            extent=(-0.5 * core_span, 0.5 * core_span, -0.5 * core_span, 0.5 * core_span),
            cmap="inferno",
            aspect="equal",
        )
        ax3.set_xlabel("x (μm)")
        ax3.set_ylabel("y (μm)")
        ax3.set_title("Field magnitude |E_y| (x–y plane)")
        fig3.colorbar(im, ax=ax3)

    if run.capture_fields and "xz" in field_maps:
        xz = field_maps["xz"]
        fig4, ax4 = plt.subplots(figsize=(5, 4))
        im = ax4.imshow(
            np.abs(xz.T),
            origin="lower",
            extent=(-0.5 * core_span, 0.5 * core_span, -0.5 * (cell_z - 2 * run.dpml_z), 0.5 * (cell_z - 2 * run.dpml_z)),
            cmap="inferno",
            aspect="auto",
        )
        ax4.set_xlabel("x (μm)")
        ax4.set_ylabel("z (μm)")
        ax4.set_title("Field magnitude |E_y| (x–z plane)")
        fig4.colorbar(im, ax=ax4)

    plt.tight_layout()
    plt.show()


# --------------------------------------------------------------------------- #
# CLI
# --------------------------------------------------------------------------- #
def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="3D Faraday rotation simulation.")
    parser.add_argument("--mode", choices=("quick", "full"), default="quick",
                        help="Select quick sanity run or full-resolution simulation.")
    parser.add_argument("--materials", choices=("library", "constant", "fit"), default="library",
                        help="Material model for SiN/SiO2.")
    parser.add_argument("--nH", type=float, default=None,
                        help="Override high-index value when --materials constant.")
    parser.add_argument("--nL", type=float, default=None,
                        help="Override low-index value when --materials constant.")
    parser.add_argument("--sin-fit", type=str, default=None,
                        help="CSV with wavelength_nm,n,k for SiN when --materials fit.")
    parser.add_argument("--sio2-fit", type=str, default=None,
                        help="CSV with wavelength_nm,n,k for SiO2 when --materials fit.")
    parser.add_argument("--fit-poles", type=int, default=6,
                        help="Number of Lorentz/Drude poles when fitting dispersive materials.")
    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    if args.materials == "fit" and (args.sin_fit is None or args.sio2_fit is None):
        raise SystemExit("For --materials fit provide both --sin-fit and --sio2-fit CSV paths.")
    run_simulation(args)
